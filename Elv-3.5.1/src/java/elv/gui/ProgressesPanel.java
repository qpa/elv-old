/*
 * ProgressesPanel.java
 */
package elv.gui;

/**
 * Class for reprezenting the progresses of an execution.
 * @author Qpa
 */
public class ProgressesPanel extends javax.swing.JPanel implements java.awt.event.ActionListener, elv.util.Saveable
{
  
  /**
   * Constant.
   */
  public final static int REFRESH_DELAY = 2000;
  
  /**
   * Variables.
   */
  private elv.task.Task task;
  
  private java.util.Stack<elv.util.Progress> progresses;
  private java.util.Stack<elv.util.Progress> previousProgresses;
  private javax.swing.Timer timer;
  private elv.util.State state;
 
  /** 
   * Constructor.
   * @param task A <CODE>elv.task.Task</CODE> object.
   * @param node the node with reprezentation properties.
   */
  public ProgressesPanel(elv.task.Task task)
  {
    this.task = task;
    try
    {
      // Set state change support.
      state = (elv.util.State)elv.util.Property.get(elv.task.Task.STATE_NAME, task.getProperties()).getValue();
      task.getChangeSupport().addPropertyChangeListener(elv.util.State.TITLE, new java.beans.PropertyChangeListener()
      {
        public void propertyChange(java.beans.PropertyChangeEvent evt)
        {
          stateChange(evt);
        }
      });
      
      initComponents();
      progresses = new java.util.Stack<elv.util.Progress>();
      previousProgresses = new java.util.Stack<elv.util.Progress>();
      timer = new javax.swing.Timer(REFRESH_DELAY, this);
      paintProgresses();
      timer.start();
    }
    catch(java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(this, exc);
    }
  }
  
  /** 
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    executableLabel = new javax.swing.JLabel();
    progressLabel = new javax.swing.JLabel();

    setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.Y_AXIS));

    executableLabel.setText(elv.util.Util.translate(elv.util.Util.NAME));
    add(executableLabel);

    progressLabel.setText(elv.util.Util.translate(elv.util.Progress.INITIALIZE));
    progressLabel.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(0, 20, 0, 0)));
    add(progressLabel);

  }//GEN-END:initComponents
  
  /**
   * Method for state change.
   * @param evt A <CODE>java.beans.PropertyChangeEvent</CODE> object.
   */
  private synchronized void stateChange(java.beans.PropertyChangeEvent evt)
  {
    try
    {
      state = (elv.util.State)evt.getNewValue();
      if(state.equals(new elv.util.State(elv.util.State.EXECUTED)))
      {
        paintProgresses();
        timer.start();
      }
      else
      {
        paintProgresses();
        timer.stop();
      }
    }
    catch(java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(this, exc);
    }
  }
   /**
   * Overridden method from <CODE>java.awt.event.ActionListener</CODE>.
   * @param event A <CODE>java.awt.event.ActionEvent</CODE> object.
   */
  public void actionPerformed(java.awt.event.ActionEvent event)
  {
    paintProgresses();
  }
  
  /**
   * Method for painting the execution progresses.
   */
  private synchronized void paintProgresses()
  {
    try
    {
      java.util.Vector executableAndProgresses = elv.util.client.ClientStub.getExecutionProgresses(task);
      elv.task.executables.Executable executable = (elv.task.executables.Executable)executableAndProgresses.get(0);
      if(!executable.toString().equals(executableLabel.getText()))
      {
        executableLabel.setText(executable.toString());
        executableLabel.setIcon(new elv.util.Node(executable).getIcon());
      }
      progresses = (java.util.Stack<elv.util.Progress>)executableAndProgresses.get(1);
    
      progressLabel.setText(elv.util.Util.translate(elv.util.Progress.PARSE) + "...");
      
      int componentIndex = 2;
      for(int i = 0; i < (progresses.size() > previousProgresses.size() ? progresses.size() : previousProgresses.size()); i++)
      {
        elv.util.Progress progress = null;
        elv.util.Progress previousProgress = null;
        ProgressPanel progressPanel = null;
        try
        {
          progress = progresses.get(i);
          previousProgress = previousProgresses.get(i);
        }
        catch(java.lang.Exception exc)
        {
        }
        if(progress != null && previousProgress != null && progress.isVisible())
        {
          progressPanel = (ProgressPanel)getComponent(componentIndex);
          if(progress.equals(previousProgress) && progress.getValue() != previousProgress.getValue())
          {
            progressPanel.set(progress.getValue());
          }
          else 
          {
            progressPanel = new ProgressPanel(progress);
          }
          componentIndex ++;
        }
        else if(progress != null && progress.isVisible())
        {
          progressPanel = new ProgressPanel(progress);
          add(progressPanel);
        }
        else if(previousProgress != null && previousProgress.isVisible())
        {
          progressPanel = (ProgressPanel)getComponent(componentIndex);
          remove(progressPanel);
          progressPanel = null;
        }
        java.lang.Thread.yield();
      }
      
      if(progresses.isEmpty())
      {
        if(state.equals(new elv.util.State(elv.util.State.EXECUTED)))
        {
          progressLabel.setText(elv.util.Util.translate(elv.util.Progress.INITIALIZE) + "...");
        }
        else if(state.equals(new elv.util.State(elv.util.State.DONE)))
        {
          progressLabel.setText("");
        }
      }
      if(!state.equals(new elv.util.State(elv.util.State.EXECUTED)))
      {
        progressLabel.setText(state.toString());
        timer.stop();
      }
      progressLabel.setIcon(state.getIcon());
      previousProgresses = progresses;
      repaint();
    }
    catch(java.io.FileNotFoundException fexc)
    {
      timer.stop();
    }
    catch(java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(this, exc);
      timer.stop();
    }
  }
  
  /**
   * Implemented method from <CODE>elv.util.Saveable</CODE>.
   * @return the changeable owner object.
   */
  public elv.util.Changeable getOwner()
  {
    return task;
  }
  
  /**
   * Implemented method from <CODE>elv.util.Saveable</CODE>.
   * @return the type object.
   */
  public java.lang.Object getType()
  {
    return null;
  }
  
  /**
   * Implemented method from <CODE>elv.util.Saveable</CODE>.
   */
  public void save()
  {
  }
  
  /**
   * Implemented method from <CODE>elv.util.Saveable</CODE>.
   * @return true if there were changes.
   */
  public boolean isChanged()
  {
    return false;
  }  
  
  /**
   * Implemented method from <CODE>elv.util.Saveable</CODE>.
   * @param isChanged boolean to set the change state.
   */
  public void setChanged(boolean isChanged)
  {
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JLabel executableLabel;
  private javax.swing.JLabel progressLabel;
  // End of variables declaration//GEN-END:variables
  
}
