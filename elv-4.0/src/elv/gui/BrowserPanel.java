/*
 * BrowserPanel.java
 */
package elv.gui;

/**
 * Class for browsing objects.
 * @author Elv
 */
public class BrowserPanel extends javax.swing.JPanel implements java.awt.event.ActionListener
{
  
  // Variables.
  /** The main frame. */
  private Manager mainFrame;
  /** The application root. */
  private elv.util.Root root;
  /** The vector of application children. */
  private java.util.Vector<java.util.Vector> appVectorOfChildren;
  /** The timer object for refreshing the ELV tree. */
  private javax.swing.Timer timer;
  
  /**
   * Constructor.
   * @param mainFrame the main frame.
   * @param root the application root.
   * @param appVectorOfChildren the vector of application children.
   */
  public BrowserPanel(Manager mainFrame, elv.util.Root root, java.util.Vector<java.util.Vector> appVectorOfChildren)
  {
    this.mainFrame = mainFrame;
    this.root = root;
    this.appVectorOfChildren = appVectorOfChildren;
    try
    {
      initComponents();
      // Register view expansion on browser tree.
      ViewExpansion.register(browserTree);
      // Start refreshig timer.
      int refreshDelay = ((java.lang.Integer)elv.util.Property.get(elv.util.User.REFRESH_DELAY_NAME, elv.util.Util.getActualUser().getProperties()).getValue()).intValue();
      if(refreshDelay > 0)
      {
        timer = new javax.swing.Timer(refreshDelay, this);
        timer.start();
      }
    }
    catch (java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(mainFrame, exc);
    }
  }
  
  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
  private void initComponents()
  {

    browserScrollPane = new javax.swing.JScrollPane();
    browserTree = new javax.swing.JTree();

    setLayout(new java.awt.BorderLayout());

    browserTree.setCellEditor(new BrowserTreeCellEditor());
    browserTree.setCellRenderer(new BrowserTreeCellRenderer());
    browserTree.setModel(new BrowserTreeModel(root, appVectorOfChildren));
    browserTree.addMouseListener(new java.awt.event.MouseAdapter()
    {
      public void mousePressed(java.awt.event.MouseEvent evt)
      {
        browserTreeMousePressed(evt);
      }
      public void mouseReleased(java.awt.event.MouseEvent evt)
      {
        browserTreeMouseReleased(evt);
      }
    });
    browserScrollPane.setViewportView(browserTree);

    add(browserScrollPane, java.awt.BorderLayout.CENTER);
  }// </editor-fold>//GEN-END:initComponents

private void browserTreeMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_browserTreeMousePressed
  mousePressedAction(evt);
}//GEN-LAST:event_browserTreeMousePressed

private void browserTreeMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_browserTreeMouseReleased
  mouseReleasedAction(evt);
}//GEN-LAST:event_browserTreeMouseReleased

  /**
   * Method for mouse pressed action.
   */
  private synchronized void mousePressedAction(java.awt.event.MouseEvent evt)
  {
    try
    {
      javax.swing.tree.TreePath treePath = browserTree.getClosestPathForLocation(evt.getX(), evt.getY());
      if(browserTree.getPathBounds(treePath).contains(evt.getPoint()))
      {
        browserTree.setSelectionPath(treePath);
        elv.util.Node treeNode = (elv.util.Node)browserTree.getLastSelectedPathComponent();
        mainFrame.setActions();
        if(evt.getClickCount() == 2)
        {
          mainFrame.browserAction(treeNode.getUserObject());
        }
      }
    }
    catch(java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(mainFrame, exc);
    }
  }
  
  /**
   * Method for mouse released action.
   */
  private synchronized void mouseReleasedAction(java.awt.event.MouseEvent evt)
  {
    try
    {
      if(evt.getButton() == 3)
      {
        javax.swing.tree.TreePath treePath = browserTree.getClosestPathForLocation(evt.getX(), evt.getY());
        if(browserTree.getPathBounds(treePath).contains(evt.getPoint()))
        {
          mainFrame.getBrowserPopupMenu().show(evt.getComponent(), evt.getX(), evt.getY());
        }
      }
    }
    catch(java.lang.Exception exc)
    {
      elv.util.Error.showErrorMessage(mainFrame, exc);
    }
  }
  
  /**
   * Implemented method from <CODE>java.awt.event.ActionListener</CODE>.
   * @param e action event.
   */
  public synchronized void actionPerformed(java.awt.event.ActionEvent e)
  {
    java.awt.EventQueue.invokeLater(new Runnable()
    {
      public void run()
      {
        refresh();
      }
    });
  }
  
  /**
   * Method for getting the browser tree.
   * @return the browser tree.
   */
  public javax.swing.JTree getTree()
  {
    return browserTree;
  }
  
  /**
   * Method for refreshing the browser tree.
   */
  public void refresh()
  {
    ((BrowserTreeModel)browserTree.getModel()).refresh();
  }
  
  /**
   * Method for refreshing a node of the browser tree.
   * @param node the node to refresh.
   */
  public void refresh(elv.util.Node node)
  {
    ((BrowserTreeModel)browserTree.getModel()).refresh(node);
  }
  
  /**
   * Inner class for the browser tree cell rendering.
   */
  private class BrowserTreeCellRenderer extends javax.swing.tree.DefaultTreeCellRenderer
  {
    
    /**
     * Overridden method from <CODE>javax.swing.tree.DefaultTreeCellRenderer</CODE>.
     */
    public java.awt.Component getTreeCellRendererComponent(javax.swing.JTree tree, java.lang.Object treeNode, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus)
    {
      super.getTreeCellRendererComponent(tree, treeNode, sel, expanded, leaf, row, hasFocus);
      javax.swing.JPanel rendererComponent = new javax.swing.JPanel();
      try
      {
        rendererComponent.setBackground(javax.swing.UIManager.getDefaults().getColor("Tree.background"));
        rendererComponent.setLayout(new javax.swing.BoxLayout(rendererComponent, javax.swing.BoxLayout.X_AXIS));
        javax.swing.JLabel iconLabel = new javax.swing.JLabel();
        rendererComponent.add(iconLabel);
        rendererComponent.add(this);
        
        iconLabel.setIcon(((elv.util.Node)treeNode).getIcon());
        setIcon(((elv.util.Node)treeNode).getStateIcon());
        rendererComponent.setToolTipText(((elv.util.Node)treeNode).getToolTipText());
      }
      catch(java.lang.Exception exc)
      {
        elv.util.Error.showErrorMessage(mainFrame, exc);
      }
      return rendererComponent;
    }
  }
  
  /**
   * Inner class for the browser tree model.
   */
  protected class BrowserTreeModel extends javax.swing.tree.DefaultTreeModel
  {
    
    /**
     * Constructor.
     * @param root 
     * @param vectorOfChildren 
     */
    public BrowserTreeModel(elv.util.Root root, java.util.Vector<java.util.Vector> vectorOfChildren)
    {
      super(new elv.util.Node(root));
      try
      {
        elv.util.Node rootNode = (elv.util.Node)getRoot();
        java.util.Vector children = elv.util.Util.getActualUser().getRelatives(vectorOfChildren.get(1));
        for(int x = 0; x < children.size(); x++)
        {
          elv.util.Node iteratorNewNode = new elv.util.Node(children.get(x));
          int insertIndex = rootNode.getChildCount();
          for(int i = rootNode.getChildCount() - 1; i >= 0; i--)
          {
            elv.util.Node iteratorExistingNode = (elv.util.Node)rootNode.getChildAt(i);
            if(elv.util.Util.getActualCollator().compare(iteratorNewNode.toString(), iteratorExistingNode.toString()) < 0)
            {
              insertIndex = i;
            }
          }
          if(!(iteratorNewNode.getUserObject() instanceof elv.task.Task))
          {
            iteratorNewNode.add(new elv.util.Node(elv.util.Node.DUMMY));
          }
          rootNode.insert(iteratorNewNode, insertIndex);
        }
      }
      catch (Exception exc)
      {
        elv.util.Error.showErrorMessage(mainFrame, exc);
//        rootNode.setState(new elv.util.State(elv.util.State.ERROR));
//        nodeChanged(rootNode);
      }
    }
    
    /**
     * Method for refreshing the children of expanded nodes.
     */
    public synchronized void refresh()
    {
      java.util.Vector<elv.util.Node> nodes = new java.util.Vector<elv.util.Node>();
      elv.util.Node node = (elv.util.Node)getRoot();
      for(int i = 0; i < browserTree.getRowCount(); i++)
      {
        if(browserTree.isExpanded(i))
        {
          nodes.add((elv.util.Node)browserTree.getPathForRow(i).getLastPathComponent());
        }
      }
      refresh(nodes);
      if(browserTree.getLastSelectedPathComponent() == null)
      {
        browserTree.setSelectionRow(0);
      }
      mainFrame.setActions();
    }
    
    /**
     * Method for refreshing the children of a node.
     * @param node the refreshable node.
     */
    public synchronized void refresh(elv.util.Node node)
    {
      java.util.Vector<elv.util.Node> nodes = new java.util.Vector<elv.util.Node>();
      nodes.add(node);
      refresh(nodes);
    }
    
    /**
     * Method for refreshing the children of the nodes.
     * @param nodes the vector of refreshable nodes.
     */
    private synchronized void refresh(java.util.Vector<elv.util.Node> nodes)
    {
      //    elv.util.SwingWorker worker = new elv.util.SwingWorker()
      //    {
      //      public java.lang.Object construct()
      //      {
      try
      {
        java.util.Vector<elv.util.Parentable> parentables = new java.util.Vector<elv.util.Parentable>();
        for(elv.util.Node iteratorNode : nodes)
        {
          java.lang.Object userObject = iteratorNode.getUserObject();
          parentables.add(userObject == null ? null : (elv.util.Parentable)userObject);
        }
        
        java.util.Vector<java.util.Vector> vectorOfChildren = elv.util.client.ClientStub.loadChildren(parentables);
        for(int n = 0; n < nodes.size(); n++)
        {
          elv.util.Node parentNode = nodes.get(n);
          java.util.Vector children = vectorOfChildren.get(n);
          if(children != null && parentNode.getUserObject() instanceof elv.util.Root)
          {
            children = elv.util.Util.getActualUser().getRelatives(vectorOfChildren.get(0));
          }
          parentables.get(n).setChildren(children);
          
          java.util.Vector<elv.util.Node> removableNodes = new java.util.Vector<elv.util.Node>();
          for(int i = 0; i < parentNode.getChildCount(); i++)
          {
            removableNodes.add((elv.util.Node)parentNode.getChildAt(i));
          }
          if(children == null) // NULL children means parentNode no longer exists.
          {
            removableNodes.add(parentNode);
          }
          for(int x = 0; children != null && x < children.size(); x++)
          {
            elv.util.Node iteratorNewNode = new elv.util.Node(children.get(x));
            int insertIndex = parentNode.getChildCount();
            int existingIndex = -1;
            elv.util.Node childNode = null;
            for(int i = parentNode.getChildCount() - 1; i >= 0; i--)
            {
              elv.util.Node iteratorExistingNode = (elv.util.Node)parentNode.getChildAt(i);
              if(iteratorExistingNode.equals(iteratorNewNode))
              {
                removableNodes.remove(iteratorExistingNode);
                childNode = iteratorExistingNode;
                iteratorExistingNode.setState(iteratorNewNode.getState());
                existingIndex = i;
                if(iteratorExistingNode.getUserObject() instanceof elv.task.Task) // Tasks can change.
                {
                  elv.task.Task existingTask = (elv.task.Task)iteratorExistingNode.getUserObject();
                  elv.task.Task newTask = (elv.task.Task)iteratorNewNode.getUserObject();
                  elv.util.State oldState = (elv.util.State)elv.util.Property.get(elv.task.Task.STATE_NAME, existingTask.getProperties()).getValue();
                  elv.util.State newState = (elv.util.State)elv.util.Property.get(elv.task.Task.STATE_NAME, newTask.getProperties()).getValue();
                  if(!oldState.equals(newState))
                  {
                    iteratorExistingNode.setState(newState);
                    nodeChanged(iteratorExistingNode);
                    existingTask.getChangeSupport().firePropertyChange(elv.util.State.TITLE, oldState, newState);
                    if(newState.equals(new elv.util.State(elv.util.State.DONE)))
                    {
                      existingTask.getChangeSupport().firePropertyChange(new elv.util.Action(elv.util.Action.CLEAN).getName(), existingTask, null);
                    }
                  }
                }
                if(iteratorExistingNode.getUserObject() instanceof elv.util.Propertable) // Properties can change.
                {
                  elv.util.Propertable existingPropertable = (elv.util.Propertable)iteratorExistingNode.getUserObject();
                  elv.util.Propertable newPropertable = (elv.util.Propertable)iteratorNewNode.getUserObject();
                  existingPropertable.setProperties(newPropertable.getProperties());
                }
              }
              if(elv.util.Util.getActualCollator().compare(iteratorNewNode.toString(), iteratorExistingNode.toString()) <= 0)
              {
                insertIndex = i;
              }
            }
            if(childNode != null && childNode.equals(new elv.util.Node(elv.util.Node.DUMMY))) // Remove the Dummy node.
            {
              removeNodeFromParent(childNode);
            }
            else if(childNode != null && insertIndex != existingIndex) // Move the renamed node.
            {
              removeNodeFromParent(childNode);
              insertNodeInto(childNode, parentNode, insertIndex);
              browserTree.scrollPathToVisible(new javax.swing.tree.TreePath(childNode.getPath()));
            }
            else if(childNode == null) // Insert new node.
            {
              insertNodeInto(iteratorNewNode, parentNode, insertIndex);
              browserTree.scrollPathToVisible(new javax.swing.tree.TreePath(iteratorNewNode.getPath()));
              if(!(iteratorNewNode.getUserObject() instanceof elv.task.Task))
              {
                iteratorNewNode.add(new elv.util.Node(elv.util.Node.DUMMY));
              }
            }
            java.lang.Thread.yield();
          }
          // Remove deleted nodes.
          for(elv.util.Node iteratorNode : removableNodes)
          {
            try
            {
              removeNodeFromParent(iteratorNode);
            }
            catch(java.lang.Exception exc)
            {
            }
            if(iteratorNode.getUserObject() instanceof elv.util.Changeable)
            {
              ((elv.util.Changeable)iteratorNode.getUserObject()).getChangeSupport().firePropertyChange(new elv.util.Action(elv.util.Action.DELETE).getName(), iteratorNode.getUserObject(), null);
            }
          }
        }
      }
      catch(java.lang.Exception exc)
      {
        elv.util.Error.showErrorMessage(mainFrame, exc);
        if(timer != null)
        {
          timer.stop();
        }
        elv.util.Node rootNode = (elv.util.Node)getRoot();
        rootNode.setState(new elv.util.State(elv.util.State.ERROR));
        nodeChanged(rootNode);
      }
      //        return null;
      //      }
      //    };
      //    worker.setThreadPriority(java.lang.Thread.MIN_PRIORITY);
      //    worker.start();
    }
    
  }
  
  /**
   * Inner class for the browser tree cell editing.
   */
  private class BrowserTreeCellEditor extends javax.swing.tree.DefaultTreeCellEditor
  {
    
    /**
     * Variable.
     */
    private java.lang.Object nodeObject;
    
    /**
     * Constructor.
     */
    public BrowserTreeCellEditor()
    {
      super(browserTree, new BrowserTreeCellRenderer(), new javax.swing.DefaultCellEditor(new javax.swing.JTextField()));
      realEditor = new BrowserCellEditor();
    }
    
    /**
     * Overridden method from javax.swing.DefaultCellEditor.
     */
    public java.lang.Object getCellEditorValue()
    {
      return nodeObject;
    }
    
    /**
     * Overridden method from javax.swing.tree.DefaultTreeCellEditor.
     */
    public synchronized java.awt.Component getTreeCellEditorComponent(javax.swing.JTree tree, java.lang.Object treeNode, boolean isSelected, boolean expanded, boolean leaf, int row)
    {
      try
      {
        super.getTreeCellEditorComponent(tree, treeNode, isSelected, expanded, leaf, row);
        elv.util.Node node = (elv.util.Node)treeNode;
        editingIcon = node.getIcon();
        nodeObject = node.getUserObject();
      }
      catch(java.lang.Exception exc)
      {
        elv.util.Error.showErrorMessage(mainFrame, exc);
      }
      return editingContainer;
    }
    
    /**
     * Inner class for the browser tree cell editing.
     */
    private class BrowserCellEditor extends javax.swing.DefaultCellEditor
    {
      
      /**
       * Constructor.
       */
      public BrowserCellEditor()
      {
        super(new javax.swing.JTextField());
      }
      
      /**
       * Overridden method from javax.swing.DefaultCellEditor.
       */
      public boolean isCellEditable(java.util.EventObject evt)
      {
        boolean isEditable = false;
        elv.util.Node treeNode = (elv.util.Node)browserTree.getLastSelectedPathComponent();
        if(treeNode != null)
        {
          if((treeNode.getUserObject() instanceof elv.util.User && elv.util.Util.getActualUser().getType() == elv.util.User.ADMINISTRATOR) ||
            (treeNode.getUserObject() instanceof elv.task.Task && !(((elv.task.Task)treeNode.getUserObject()).getContainer() instanceof elv.task.Archive)) ||
            treeNode.getUserObject() instanceof elv.task.Container)
          {
            isEditable = true;
          }
        }
        return isEditable;
      }
      
      /**
       * Overridden method from javax.swing.DefaultCellEditor.
       */
      public java.lang.Object getCellEditorValue()
      {
        return nodeObject;
      }
      
      /**
       * Overridden method from javax.swing.DefaultCellEditor.
       */
      public synchronized java.awt.Component getTreeCellEditorComponent(javax.swing.JTree tree, java.lang.Object treeNode, boolean isSelected, boolean expanded, boolean leaf, int row)
      {
        try
        {
          super.getTreeCellEditorComponent(tree, treeNode, isSelected, expanded, leaf, row);
          javax.swing.JTextField editorField =  (javax.swing.JTextField)editorComponent;
          final elv.util.Node node = (elv.util.Node)treeNode;
          nodeObject = node.getUserObject();
          editorField.setText(node.toString());
          editorField.selectAll();
          editorField.addActionListener(new java.awt.event.ActionListener()
          {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
              try
              {
                javax.swing.JTextField editorField =  (javax.swing.JTextField)evt.getSource();
                if(!node.toString().equals(editorField.getText()))
                {
                  java.lang.String[] newDescriptions = new java.lang.String[2];
                  newDescriptions[0] = "";
                  newDescriptions[1] = node.getToolTipText();
                  if(nodeObject instanceof elv.util.User)
                  {
                    elv.util.User user = (elv.util.User)nodeObject;
                    elv.util.client.ClientStub.move(user, new elv.util.User(user.getRoot(), editorField.getText(), user.getType()));
                    user.setName(editorField.getText());
                    newDescriptions[0] = user.toString();
                  }
                  else if(nodeObject instanceof elv.task.Container)
                  {
                    elv.task.Container container = (elv.task.Container)nodeObject;
                    elv.task.Container newContainer = new elv.task.Container(container.getUser(), editorField.getText());
                    if(nodeObject instanceof elv.task.Archive)
                    {
                      newContainer = new elv.task.Archive(container.getUser(), editorField.getText());
                    }
                    elv.util.client.ClientStub.move((elv.task.Container)nodeObject, newContainer);
                    container.setName(editorField.getText());
                    newDescriptions[0] = container.toString();
                  }
                  else if(nodeObject instanceof elv.task.Task)
                  {
                    elv.task.Task task = (elv.task.Task)nodeObject;
                    elv.util.client.ClientStub.move(task, new elv.task.Task(task.getContainer(), editorField.getText(), task.getType()));
                    task.setName(editorField.getText());
                    newDescriptions[0] = task.toString();
                  }
                  if(nodeObject instanceof elv.util.Changeable)
                  {
//                    newDescriptions[0] = node.toString();
//                    newDescriptions[1] = node.getToolTipText();
                    ((elv.util.Changeable)nodeObject).getChangeSupport().firePropertyChange(new elv.util.Action(elv.util.Action.RENAME).getName(), nodeObject, newDescriptions);
                  }
                }
                stopCellEditing();
                refresh((elv.util.Node)node.getParent());
//                ((BrowserTreeModel)elvTree.getModel()).nodeChanged(node);
              }
              catch(java.lang.Exception exc)
              {
                elv.util.Error.showErrorMessage(mainFrame, exc);
              }
              
              finally
              {
                
              }
            }
          });
        }
        catch(java.lang.Exception exc)
        {
          elv.util.Error.showErrorMessage(mainFrame, exc);
        }
        return editorComponent;
      }
    }
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JScrollPane browserScrollPane;
  private javax.swing.JTree browserTree;
  // End of variables declaration//GEN-END:variables
  
}
