/*
 * MultiSplitDockingPanel.java
 */
package elv.gui;

/**
 * Class for representing a multi splitted docking panel.
 * @author Elv
 */
public class MultiSplitDockingPanel extends javax.swing.JPanel
{
  
  // Variables.
  /** The docking toolbar. */
  private javax.swing.JToolBar dockingToolBar = null;
  /**
   * The toolbar orientation. One of <code>java.awt.BorderLayout.EST</code>, <code>java.awt.BorderLayout.WEST</code>
   * <code>java.awt.BorderLayout.NORTH</code>, <code>java.awt.BorderLayout.SOUTH</code> constants or <code>null</code> if no toolbar needed.
   */
  private java.lang.String toolBarOrientation;
  /** The size of the split dividers. */
  private int divSize = 5;
  /** The layout of the split panes. */
  private boolean contLayout = true;
  /** The root of tree model. */
  private Node model = null;
  
  /**
   * Constructor.
   */
  public MultiSplitDockingPanel()
  {
    this(java.awt.BorderLayout.WEST);
  }
  
  /**
   * Constructor.
   * @param toolBarOrientation the toolbar orientation. One of <code>java.awt.BorderLayout.EAST</code>, <code>java.awt.BorderLayout.WEST</code>
   * <code>java.awt.BorderLayout.NORTH</code>, <code>java.awt.BorderLayout.SOUTH</code> constants or <code>null</code> if no toolbar needed.
   */
  public MultiSplitDockingPanel(java.lang.String toolBarOrientation)
  {
    this.toolBarOrientation = toolBarOrientation;
    initComponents();
    if(toolBarOrientation != null)
    {
      
      if(!java.awt.BorderLayout.EAST.equals(toolBarOrientation) && !java.awt.BorderLayout.WEST.equals(toolBarOrientation) &&
         !java.awt.BorderLayout.NORTH.equals(toolBarOrientation) && !java.awt.BorderLayout.SOUTH.equals(toolBarOrientation))
      {
        throw new java.lang.IllegalArgumentException("Toolbar orientation must be one of java.awt.BorderLayout.EAST, java.awt.BorderLayout.WEST, " +
          "java.awt.BorderLayout.NORTH, java.awt.BorderLayout.SOUTH constants!");
      }
      else
      {
        dockingToolBar = new  javax.swing.JToolBar();
        dockingToolBar.setFloatable(false);
        if(java.awt.BorderLayout.NORTH.equals(toolBarOrientation) || java.awt.BorderLayout.SOUTH.equals(toolBarOrientation))
        {
          dockingToolBar.setOrientation(0);
        }
        else
        {
          dockingToolBar.setOrientation(1);
        }
        add(dockingToolBar, toolBarOrientation);
      }
    }
  }
  
  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
  private void initComponents()
  {

    setLayout(new java.awt.BorderLayout());
  }// </editor-fold>//GEN-END:initComponents
  
  /**
   * Method for getting the docking tool bar.
   * @return the dockingToolBar property.
   */
  public javax.swing.JToolBar getDockingToolBar()
  {
    return dockingToolBar;
  }
  
  /**
   * Method for selecting the given split component.
   * @param component the specified component.
   */
  public void setSelectedSplit(java.awt.Component component)
  {
    setSelectedSplitImpl(component, model);
  }
  
  /**
   * Method for selecting the given split component from the specified node.
   */
  private void setSelectedSplitImpl(java.awt.Component component, Node node)
  {
    if(node instanceof Leaf)
    {
      if(component instanceof DockingFrame)
      {
        if(component == node.getComponent())
        {
          ((DockingFrame)component).setSelectedIndex(0);
        }
        else
        {
          ((DockingFrame)component).setSelectedIndex(-1);
        }
      }
    }
    else if(node instanceof Split)
    {
      setSelectedSplitImpl(component, ((Split)node).getLeft());
      setSelectedSplitImpl(component, ((Split)node).getRight());
    }
  }
  
  /**
   * Method for adding a split component and the associated button (if needed).
   * @param component the component to be added.
   * @param childPath the splitting treepath of the component.
   * @param dividerLocation the divider location of split
   */
  public void addDockingComponent(final java.awt.Component component, java.lang.String path, int dividerLocation, boolean isVisible)
  {
    // Set the toggle button.
    if(dockingToolBar != null)
    {
      final javax.swing.JToggleButton childButton = new javax.swing.JToggleButton();
      childButton.setFocusable(false);
      childButton.setSelected(java.lang.Boolean.valueOf(isVisible));
      if(component instanceof DockingFrame)
      {
        childButton.setIcon(((DockingFrame)component).getIcon());
        childButton.setToolTipText(((DockingFrame)component).getTitle());
      }
      childButton.addActionListener(new java.awt.event.ActionListener()
      {
        public void actionPerformed(java.awt.event.ActionEvent evt)
        {
          setVisibleDockingComponent(component, childButton.isSelected());
        }
      });
      dockingToolBar.add(childButton);
    }
  }
  
  /**
   * Method for adding a component to the split pane.
   * @param component the component which will be added.
   */
  private void addSplitComponent(java.awt.Component component)
  {
    if(isSplit(component, getRootComponent()))
    {
      return;
    }
    Node componentNode = findNode(component, model);
    Split parent = componentNode.getParent();
    Split previousParent = null;
    while(parent != null)
    {
      if(isSplit(parent.getComponent(), getRootComponent()))
      {
        break;
      }
      previousParent = parent;
      parent = parent.getParent();
    }
    if(previousParent == null)
    {
      add(component, java.awt.BorderLayout.CENTER);
    }
    else
    {
      if(parent == null)
      {
        java.awt.Component sibling = getRootComponent();
        if(sibling == null)
        {
          add(component, java.awt.BorderLayout.CENTER);
        }
        else
        {
          Node siblingNode = findNode(sibling, model);
          remove(sibling);
          if(previousParent.getLeft().isAncestor(siblingNode))
          {
            Split commonAncestorSplit = siblingNode.getCommonAncestor(componentNode);
            javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
            if(commonAncestorSplit.getLeft().getComponent() == component)
            {
              splitPane.setLeftComponent(component);
              splitPane.setRightComponent(sibling);
            }
            else
            {
              splitPane.setLeftComponent(sibling);
              splitPane.setRightComponent(component);
            }
            splitPane.setDividerLocation(splitPane.getLastDividerLocation());
            add(splitPane, java.awt.BorderLayout.CENTER);
            splitPane.revalidate();
          }
          else if(previousParent.getRight().isAncestor(siblingNode))
          {
            Split commonAncestorSplit = siblingNode.getCommonAncestor(componentNode);
            javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
            if(commonAncestorSplit.getLeft().getComponent() == component)
            {
              splitPane.setLeftComponent(component);
              splitPane.setRightComponent(sibling);
            }
            else
            {
              splitPane.setLeftComponent(sibling);
              splitPane.setRightComponent(component);
            }
            splitPane.setDividerLocation(splitPane.getLastDividerLocation());
            add(splitPane, java.awt.BorderLayout.CENTER);
            splitPane.revalidate();
          }
        }
      }
      else
      {
        javax.swing.JSplitPane parentSplitPane = (javax.swing.JSplitPane)parent.getComponent();
        Node leftSiblingNode = findNode(parentSplitPane.getLeftComponent(), model);
        Node rightSiblingNode = findNode(parentSplitPane.getRightComponent(), model);
        if(previousParent.getLeft().isAncestor(leftSiblingNode))
        {
          java.awt.Component sibling = leftSiblingNode.getComponent();
          parentSplitPane.remove(sibling);
          Split commonAncestorSplit = leftSiblingNode.getCommonAncestor(componentNode);
          javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
          if(commonAncestorSplit.getLeft().getComponent() == component)
          {
            splitPane.setLeftComponent(component);
            splitPane.setRightComponent(sibling);
          }
          else
          {
            splitPane.setLeftComponent(sibling);
            splitPane.setRightComponent(component);
          }
          splitPane.setDividerLocation(splitPane.getLastDividerLocation());
          parentSplitPane.add(splitPane);
          splitPane.revalidate();
        }
        else if(previousParent.getLeft().isAncestor(rightSiblingNode))
        {
          java.awt.Component sibling = rightSiblingNode.getComponent();
          parentSplitPane.remove(sibling);
          Split commonAncestorSplit = rightSiblingNode.getCommonAncestor(componentNode);
          javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
          if(commonAncestorSplit.getLeft().getComponent() == component)
          {
            splitPane.setLeftComponent(component);
            splitPane.setRightComponent(sibling);
          }
          else
          {
            splitPane.setLeftComponent(sibling);
            splitPane.setRightComponent(component);
          }
          splitPane.setDividerLocation(splitPane.getLastDividerLocation());
          parentSplitPane.add(splitPane);
          splitPane.revalidate();
        }
        else if(previousParent.getRight().isAncestor(leftSiblingNode))
        {
          java.awt.Component sibling = leftSiblingNode.getComponent();
          parentSplitPane.remove(sibling);
          Split commonAncestorSplit = leftSiblingNode.getCommonAncestor(componentNode);
          javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
          if(commonAncestorSplit.getLeft().getComponent() == component)
          {
            splitPane.setLeftComponent(component);
            splitPane.setRightComponent(sibling);
          }
          else
          {
            splitPane.setLeftComponent(sibling);
            splitPane.setRightComponent(component);
          }
          splitPane.setDividerLocation(splitPane.getLastDividerLocation());
          parentSplitPane.add(splitPane);
          splitPane.revalidate();
        }
        else if(previousParent.getRight().isAncestor(rightSiblingNode))
        {
          java.awt.Component sibling = rightSiblingNode.getComponent();
          parentSplitPane.remove(sibling);
          Split commonAncestorSplit = rightSiblingNode.getCommonAncestor(componentNode);
          javax.swing.JSplitPane splitPane = (javax.swing.JSplitPane)commonAncestorSplit.getComponent();
          if(commonAncestorSplit.getLeft().getComponent() == component)
          {
            splitPane.setLeftComponent(component);
            splitPane.setRightComponent(sibling);
          }
          else
          {
            splitPane.setLeftComponent(sibling);
            splitPane.setRightComponent(component);
          }
          splitPane.setDividerLocation(splitPane.getLastDividerLocation());
          parentSplitPane.add(splitPane);
          splitPane.revalidate();
        }
        parentSplitPane.setDividerLocation(parentSplitPane.getLastDividerLocation());
        parentSplitPane.revalidate();
        parentSplitPane.repaint();
      }
    }
    revalidate();
    repaint();
//    getParent().repaint();
//    if(componentNode instanceof Leaf)
//    {
//      ((Leaf)componentNode).setVisible(true);
//    }
  }
  
  /**
   * Method for hide and show a docking component.
   * @param component the docking component.
   * @param isVisible if true, add to the side toolbar the minimized button.
   */
  public void setVisibleDockingComponent(java.awt.Component component, boolean isVisible)
  {
    if(isVisible)
    {
      addSplitComponent(component);
    }
    else
    {
      removeSplitComponent(component);
    }
  }
  
  /**
   * Method for removing a docking component: the split component and the associated docking button (if any).
   * @param component the removable docking component.
   */
  public void removeDockingComponent(java.awt.Component component)
  {
    if(!isSplit(component, getRootComponent()))
    {
      return;
    }
    removeSplitComponent(component);
  }
  
  /**
   * Method for removing a split component.
   * @param component the removable split component.
   */
  private void removeSplitComponent(java.awt.Component component)
  {
    Node componentNode = findNode(component, model);
    java.awt.Container parent = component.getParent();
    if(parent instanceof javax.swing.JSplitPane)
    {
      if(componentNode.getParent() != null)
      {
        componentNode.getParent().dividerLocation = ((javax.swing.JSplitPane)parent).getDividerLocation();
      }
      java.awt.Component sibling = ((javax.swing.JSplitPane)parent).getRightComponent() == component ?
        ((javax.swing.JSplitPane)parent).getLeftComponent() :((javax.swing.JSplitPane)parent).getRightComponent();
      java.awt.Container parentOfParent = parent.getParent();
      int dividerLocation = 0;
      if(parentOfParent instanceof javax.swing.JSplitPane)
      {
        dividerLocation = ((javax.swing.JSplitPane)parentOfParent).getDividerLocation();
      }
      parent.remove(component);
      parent.remove(sibling);
      parentOfParent.remove(parent);
      parentOfParent.add(sibling);
      if(parentOfParent instanceof javax.swing.JSplitPane)
      {
        ((javax.swing.JSplitPane)parentOfParent).setDividerLocation(dividerLocation);
      }
      ((javax.swing.JComponent)parentOfParent).revalidate();
    }
    else
    {
      parent.remove(component);
      ((javax.swing.JComponent)parent).revalidate();
    }
    repaint();
//    if(componentNode instanceof Leaf)
//    {
//      ((Leaf)componentNode).setVisible(true);
//    }
  }
  
  /**
   * Method for getting the multisplit root component.
   * @return the component placed in the CENTER of this panel.
   */
  public java.awt.Component getRootComponent()
  {
    java.awt.Component rootComponent = null;
    if(dockingToolBar == null && getComponentCount() > 0)
    {
      rootComponent = getComponents()[0];
    }
    else if(dockingToolBar != null && getComponentCount() > 1)
    {
      rootComponent = getComponents()[1];
    }
    return rootComponent;
  }
  
  /**
   * Method for setting the model of this multisplit.
   * @param model the root of the new tree model.
   */
  public void setModel(Node model)
  {
    this.model = model;
    removeNonVisible(model);
    add(model.getComponent(), java.awt.BorderLayout.CENTER);
  }
  
  /**
   * Method for removing the non visible components.
   * @param fromNode the node of the component.
   */
  private void removeNonVisible(Node fromNode)
  {
    if(fromNode instanceof Leaf && !((Leaf)fromNode).isVisible())
    {
      removeSplitComponent(fromNode.getComponent());
    }
    else if(fromNode instanceof Split)
    {
      removeNonVisible(((Split)fromNode).getLeft());
      removeNonVisible(((Split)fromNode).getRight());
    }
  }
  
  /**
   * Method for finding the node of the given component.
   * @param component the searchable component.
   */
  private Node findNode(java.awt.Component component, Node fromNode)
  {
    Node node = null;
    if(fromNode == null || fromNode.getComponent() == component)
    {
      return fromNode;
    }
    else if(fromNode instanceof Split)
    {
      node = findNode(component, ((Split)fromNode).getLeft());
      if(node == null)
      {
        node = findNode(component, ((Split)fromNode).getRight());
      }
    }
    return node;
  }
  
  /**
   * Returns whether the specified component is in the split.
   * @param component the component to check.
   */
  private boolean isSplit(java.awt.Component component, java.awt.Component fromComponent)
  {
    boolean isSplit = false;
    if(fromComponent == null)
    {
      return false;
    }
    else if(fromComponent == component)
    {
      return true;
    }
    else if(fromComponent instanceof javax.swing.JSplitPane)
    {
      isSplit = isSplit(component, ((javax.swing.JSplitPane)fromComponent).getLeftComponent());
      if(!isSplit)
      {
        isSplit = isSplit(component, ((javax.swing.JSplitPane)fromComponent).getRightComponent());
      }
    }
    return isSplit;
  }
  
  /**
   * Base class for the nodes that model a MultiSplitLayout.
   */
  public static abstract class Node
  {
    // Variables.
    /** The parent of this node. */
    private Split parent = null;
    /** The component of this node. */
    private java.awt.Component component;
    
    public Node(java.awt.Component component)
    {
      this.component = component;
    }
    
    /**
     * Returns the Split parent of this node, or null.
     * @return the value of the parent property.
     */
    public Split getParent()
    {
      return parent;
    }
    
    /**
     * Set the value of this node's parent property. The default value of this property is null.
     * @param parent a Split or null
     */
    public void setParent(Split parent)
    {
      this.parent = parent;
    }
    
    /**
     * Returns the component of this node.
     * @return the component property.
     */
    public java.awt.Component getComponent()
    {
      return component;
    }
    
    /**
     * Returns the sibling of this node.
     * @return the sibling of this node (if there is).
     */
    public Node getSibling()
    {
      Node sibling = null;
      if(parent == null)
      {
        return null;
      }
      else
      {
        if(parent.getLeft() == this)
        {
          sibling = parent.getRight();
        }
        else
        {
          sibling = parent.getLeft();
        }
      }
      return sibling;
    }
    
    /**
     * Returns true if this node is ancestor of the given node.
     * @param node the node to check.
     * @return true if the specified node is ancestor of this node.
     */
    public boolean isAncestor(Node node)
    {
      if (node == null)
      {
        return false;
      }
      Node ancestor = node;
      do
      {
        if(ancestor == this)
        {
          return true;
        }
      }
      while((ancestor = ancestor.getParent()) != null);
      return false;
    }
    
    /**
     * Returns true if this node is descendant of the given node.
     * @param node the node to check.
     * @return true if the specified node is descendant of this node.
     */
    public boolean isDescendant(Node node)
    {
      if(node == null)
      {
        return false;
      }
      return node.isAncestor(this);
    }
    
    /**
     * Returns the first common ancestor of this node with the specified node.
     * @param node the node to check.
     * @return the common ancestor.
     */
    public Split getCommonAncestor(Node node)
    {
      Split thisAncestor = this.getParent();
      do
      {
        Split nodeAncestor = node.getParent();
        do
        {
          if(thisAncestor == nodeAncestor)
          {
            return thisAncestor;
          }
        }
        while((nodeAncestor = nodeAncestor.getParent()) != null);
      }
      while((thisAncestor = thisAncestor.getParent()) != null);
      return null;
    }
    
  }
  
  /**
   * Class for reprezenting a split in the model.
   */
  public static class Split extends Node
  {
    
    // Variables.
    /** The left one node of the split. */
    private Node left = null;
    /** The rigth one node of the split. */
    private Node rigth = null;
    /** The location of the divider. */
    private int dividerLocation = 50;
    
    /**
     * Constructor.
     * @param orientation the orientation of the split.
     */
    public Split(int orientation)
    {
      super(new javax.swing.JSplitPane(orientation, true));
      ((javax.swing.JSplitPane)getComponent()).setDividerLocation(dividerLocation);
      ((javax.swing.JSplitPane)getComponent()).setBorder(null);
      ((javax.swing.JSplitPane)getComponent()).setResizeWeight(0.5);
    }
    
    /**
     * Constructor.
     * @param orientation the orientation of the split.
     */
    public Split(int orientation, int dividerLocation)
    {
      super(new javax.swing.JSplitPane(orientation, true));
      this.dividerLocation = dividerLocation;
      ((javax.swing.JSplitPane)getComponent()).setDividerLocation(dividerLocation);
      ((javax.swing.JSplitPane)getComponent()).setResizeWeight(0.5);
      ((javax.swing.JSplitPane)getComponent()).setBorder(null);
    }
    
    /**
     * Returns the left node of this split, or null.
     * @return the value of the left property.
     */
    public Node getLeft()
    {
      return left;
    }
    
    /**
     * Set the left node of this split. The default value of this property is null.
     * @param left the new left node.
     */
    public void setLeft(Node left)
    {
      this.left = left;
      left.setParent(this);
      ((javax.swing.JSplitPane)getComponent()).setLeftComponent(left.getComponent());
    }
    
    /**
     * Returns the rigth node of this split, or null.
     * @return the value of the rigth property.
     */
    public Node getRight()
    {
      return rigth;
    }
    
    /**
     * Set the rigth node of this split. The default value of this property is null.
     * @param rigth the new rigth node.
     */
    public void setRight(Node rigth)
    {
      this.rigth = rigth;
      rigth.setParent(this);
      ((javax.swing.JSplitPane)getComponent()).setRightComponent(rigth.getComponent());
    }
    
  }
  /**
   * Class for reprezenting a leaf in the model.
   */
  public static class Leaf extends Node
  {
    
    // Variable.
    /** The visible state of this leaf component. */
    private boolean isVisible = true;
    
    /**
     * Constructor.
     * @param component the component of this leaf.
     * @param isVisible reflects whether the component is visible or not.
     */
    public Leaf(java.awt.Component component, boolean isVisible)
    {
      super(component);
      this.isVisible = isVisible;
    }
    
    /**
     * Returns the visible state.
     * @return the value of the isVisible property.
     */
    public boolean isVisible()
    {
      return isVisible;
    }
    
    /**
     * Set the visible state of this node.
     * @param isVisible the new isVisible property.
     */
    public void setVisible(boolean isVisible)
    {
      this.isVisible = isVisible;
    }
    
  }
    
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  
}
