/*
 * WizardTreePanel.java
 */

package elv.gui;

/**
 * Class for showing a wizard tree.
 * @author Elv
 */
public class WizardTreePanel extends javax.swing.JPanel
{
  
  // Variables.
  /** The object which will have a child. */
  private elv.util.Parentable parentable;
  /** The <Next> button (which could be enabled or disabled). */
  private javax.swing.JButton nextButton;
  /** The selected new object. */
  private java.lang.Object selectedObject;
  /** The type of the new object. */
  private java.lang.Object selectedType;
  
  /** 
   * Constructor.
   * @param parentObject the node object in ELV tree, which will have a new child.
   * @param nextButton the <Next> button in the wizard dialog.
   */
  public WizardTreePanel(elv.util.Parentable parentable, javax.swing.JButton nextButton)
  {
    this.parentable = parentable;
    this.nextButton = nextButton;
    initComponents();
    elv.util.ViewTooltips.register(wizardTree);
  }
  
  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
  private void initComponents()
  {
    treeScrollPane = new javax.swing.JScrollPane();
    wizardTree = new javax.swing.JTree();

    setLayout(new java.awt.BorderLayout());

    wizardTree.setCellRenderer(new WizardTreeCellRenderer());
    wizardTree.setModel(new WizardTreeModel());
    wizardTree.addMouseListener(new java.awt.event.MouseAdapter()
    {
      public void mouseClicked(java.awt.event.MouseEvent evt)
      {
        wizardTreeMouseClicked(evt);
      }
    });

    treeScrollPane.setViewportView(wizardTree);

    add(treeScrollPane, java.awt.BorderLayout.CENTER);

  }// </editor-fold>//GEN-END:initComponents

  /**
   * Method for mouse click handling.
   */
  private void wizardTreeMouseClicked(java.awt.event.MouseEvent evt)//GEN-FIRST:event_wizardTreeMouseClicked
  {//GEN-HEADEREND:event_wizardTreeMouseClicked
    elv.util.Node node = (elv.util.Node)((javax.swing.JTree)evt.getSource()).getLastSelectedPathComponent();
    nextButton.setEnabled(false);
    selectedObject = null;
    if(node != null && node.isLeaf() && node.getUserObject().getClass().isInstance(selectedType))
    {
      nextButton.setEnabled(true);
      nextButton.getRootPane().setDefaultButton(nextButton);
      selectedObject = node.getUserObject();
    }
  }//GEN-LAST:event_wizardTreeMouseClicked
  
  /**
   * Method for getting the selected object.
   * @return the selected object type.
   */
  public java.lang.Object getSelectedObject()
  {
    return selectedObject;
  }
  
  /**
   * Inner class for the wizard tree model.
   */
  private class WizardTreeModel extends javax.swing.tree.DefaultTreeModel
  {
    
    /**
     * Constructor.
     */
    public WizardTreeModel()
    {
      super(new elv.util.Node(elv.util.Util.translate(elv.util.Util.OPTIONS)));
      
      try
      {
        if(parentable instanceof elv.util.Root) // User.
        {
          // New.
          elv.util.Root parentRoot = (elv.util.Root)parentable;
          elv.util.Node newNode = new elv.util.Node(new elv.util.User(parentRoot, elv.util.Util.translate(new elv.util.Action(elv.util.Action.NEW).getName()), elv.util.User.SINGLE));
          ((elv.util.Node)getRoot()).add(newNode);
          // Clone.
          elv.util.Node cloneNode = new elv.util.Node(new elv.util.Action(elv.util.Action.CLONE).toString());
          ((elv.util.Node)getRoot()).add(cloneNode);
          java.util.Vector<elv.util.User> users = parentable.getChildren();
          for(elv.util.User iteratorUser : users)
          {
            elv.util.Node iteratorUserNode =  new elv.util.Node(iteratorUser);
            cloneNode.add(iteratorUserNode);
          }
          selectedType = newNode.getUserObject();
        }
        else if(parentable instanceof elv.util.User) // Container.
        {
          // New.
          elv.util.User parentUser = (elv.util.User)parentable;
          elv.util.Node newNode = new elv.util.Node(new elv.task.Container(parentUser, elv.util.Util.translate(elv.task.Container.TITLE)));
          ((elv.util.Node)getRoot()).add(newNode);
          newNode = new elv.util.Node(new elv.task.Archive(parentUser, elv.util.Util.translate(elv.task.Archive.TITLE)));
          ((elv.util.Node)getRoot()).add(newNode);
          selectedType = newNode.getUserObject();
        }
        else if(parentable instanceof elv.task.Container)  // Task.
        {
          // New.
          elv.task.Container parentContainer = (elv.task.Container)parentable;
          elv.util.Node newNode = new elv.util.Node(elv.util.Util.translate(new elv.util.Action(elv.util.Action.NEW).getName()));
          ((elv.util.Node)getRoot()).add(newNode);
          elv.util.Node analysisNode = null;
          for(int i = 0; i < elv.task.Task.ANALYSIS_TYPES.length; i++)
          {
            analysisNode = new elv.util.Node(new elv.task.Task(parentContainer, elv.util.Util.translate(elv.task.Task.ANALYSIS_TYPES[i]), i));
            int index = 0;
            for(; index < newNode.getChildCount(); index++)
            {
              elv.util.Node iteratorNode = (elv.util.Node)newNode.getChildAt(index);
              if(elv.util.Util.getActualCollator().compare(analysisNode.toString(), iteratorNode.toString()) < 0)
              {
                break;
              }
            }
            newNode.insert(analysisNode, index);
          }
          selectedType = analysisNode.getUserObject();
          // Clone.
          elv.util.Node cloneNode = new elv.util.Node(new elv.util.Action(elv.util.Action.CLONE).toString());
          ((elv.util.Node)getRoot()).add(cloneNode);
          elv.util.Root root = elv.util.client.ClientStub.loadAllDescendants();
          java.util.Vector<elv.util.User> users = elv.util.Util.getActualUser().getRelatives(root.getChildren());
          for(elv.util.User iteratorUser : users)
          {
            elv.util.Node iteratorUserNode = new elv.util.Node(iteratorUser);
            cloneNode.add(iteratorUserNode);
            java.util.Vector<elv.task.Container> containers = iteratorUser.getChildren();
            for(elv.task.Container iteratorContainer : containers)
            {
              elv.util.Node iteratorContainerNode = new elv.util.Node(iteratorContainer);
              iteratorUserNode.add(iteratorContainerNode);
              java.util.Vector<elv.task.Task> tasks = iteratorContainer.getChildren();
              for(elv.task.Task iteratorTask : tasks)
              {
                elv.util.Node iteratorTaskNode = new elv.util.Node(iteratorTask);
                iteratorContainerNode.add(iteratorTaskNode);
              }
            }
          }
        }
      }
      catch(java.lang.Exception exc)
      {
        elv.util.Error.showErrorMessage(WizardTreePanel.this, exc);
      }
    }
    
  }
  
  /**
   * Inner class for the wizard tree cell rendering.
   */
  private class WizardTreeCellRenderer extends elv.util.Util.DefaultTreeCellRenderer
  {
    
    /**
     * Overridden method from <CODE>javax.swing.tree.DefaultTreeCellRenderer</CODE>.
     */
    public java.awt.Component getTreeCellRendererComponent(javax.swing.JTree tree, java.lang.Object treeNode, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus)
    {
      super.getTreeCellRendererComponent(tree, treeNode, sel, expanded, leaf, row, hasFocus);
      setToolTipText(null);
      try
      {
        if(treeNode instanceof elv.util.Node)
        {
          if(((elv.util.Node)treeNode).getIcon() != null)
          {
            setIcon(((elv.util.Node)treeNode).getIcon());
          }
        }
      }
      catch(java.lang.Exception exc)
      {
        elv.util.Error.showErrorMessage(this, exc);
      }
      return this;
    }
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  public javax.swing.JScrollPane treeScrollPane;
  public javax.swing.JTree wizardTree;
  // End of variables declaration//GEN-END:variables
  
}
